<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AR Graffiti Studio (WebXR)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />

    <!-- Tailwind CSS (for quick styling) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- A-Frame (3D/AR Framework) -->
    <!-- NOTE: A-Frame >= 1.4.0 automatically supports WebXR on compatible devices -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>

    <!-- REMOVED: MindAR -->
    
    <!-- FontAwesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        /* Essential for full-screen AR experience */
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        /* DOM Overlay allows UI to sit on top of the WebXR view */
        #dom-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let touches pass through to canvas by default */
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            visibility: hidden; /* Hidden until AR starts */
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: #111;
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(185, 28, 28, 0.9); /* Red-900 */
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            max-width: 90%;
            z-index: 100;
            color: white;
            display: none; /* Hidden by default */
        }

        /* Interactive elements inside the overlay must re-enable pointer-events */
        .ui-element {
            pointer-events: auto;
        }

        /* Tool Buttons */
        .tool-btn {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: rgba(20, 20, 20, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            margin-bottom: 8px;
        }
        .tool-btn.active {
            background: #3B82F6;
            border-color: white;
            transform: scale(1.1);
        }

        /* Color Buttons */
        .color-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            margin: 0 6px;
            transform: scale(1);
            transition: transform 0.2s;
        }
        .color-btn.active {
            transform: scale(1.3);
            border-color: #3B82F6;
        }

        /* Main Draw Button */
        #draw-btn {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
        }
        #draw-btn:active {
            transform: scale(0.95);
        }
        
        #reticle {
            position: absolute;
            top: 50%; left: 50%;
            width: 12px; height: 12px;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 8px rgba(0,0,0,0.5);
            transition: width 0.2s, height 0.2s, background-color 0.2s;
        }
        
        /* Ensure A-Frame's button is hidden when we use our own */
        .a-enter-ar-button {
            display: none !important;
        }
    </style>
</head>
<body class="bg-gray-900 overflow-hidden">

    <!-- Error/Feedback Message -->
    <div id="error-message" class="text-lg font-semibold">
        <h2 class="text-2xl mb-2"><i class="fas fa-exclamation-triangle mr-2"></i> AR Failed to Start</h2>
        <p>
            Your browser is either blocking necessary permissions or doesn't support the required AR standards. 
            <br>
            **Please check Camera AND Motion/Orientation Access in your iPhone Safari Settings.**
        </p>
        <p class="mt-4">
            If you continue to see this error, your specific device may not support WebXR for this application.
        </p>
    </div>

    <!-- Start Screen Overlay -->
    <div id="start-screen">
        <h1 class="text-4xl font-bold mb-4 bg-gradient-to-r from-blue-400 to-green-400 bg-clip-text text-transparent">AR Graffiti (WebXR)</h1>
        <p class="mb-8 text-gray-300 max-w-md">Paint on the real world using native iOS AR features.</p>
        <button id="start-ar-btn" class="px-8 py-4 bg-blue-600 rounded-full font-bold text-xl shadow-lg hover:bg-blue-500 transition transform hover:scale-105">
            Start AR Session
        </button>
        <p id="compatibility-check" class="mt-4 text-sm text-gray-400"></p>
        <p class="mt-8 text-xs text-gray-500">Note: This will trigger a system-level permission request for Camera access.</p>
    </div>

    <!-- A-Frame Scene (Using native WebXR for AR) -->
    <a-scene 
        id="ar-scene"
        webxr="
            requiredFeatures: [hit-test, local-floor]; 
            optionalFeatures: [dom-overlay]; 
            referenceSpaceType: local-floor;
            overlay: #dom-overlay"
        loading-screen="enabled: false"
        color-space="sRGB" 
        renderer="antialias: true; colorManagement: true; physicallyCorrectLights: true; alpha: true;">

        <!-- AR Mode Camera is handled by WebXR itself -->
        <!-- The camera entity will automatically receive positioning from the WebXR session -->
        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
        
        <!-- The container for all drawings and the drawing component -->
        <a-entity drawing-system id="drawing-container"></a-entity>

        <!-- Lighting for the spray particles -->
        <a-light type="ambient" color="#BBB"></a-light>
        <a-light type="directional" position="-1 2 1" intensity="0.5"></a-light>
    </a-scene>

    <!-- UI Overlay (Visible in AR) -->
    <div id="dom-overlay">
        
        <!-- Top Bar: Tools -->
        <div class="ui-element p-4 flex justify-between items-start w-full">
            <div class="flex flex-col">
                <button class="tool-btn active" id="tool-brush" onclick="setTool('brush')">
                    <i class="fas fa-paint-brush"></i>
                </button>
                <button class="tool-btn" id="tool-spray" onclick="setTool('spray')">
                    <i class="fas fa-spray-can"></i>
                </button>
                <button class="tool-btn" id="tool-eraser" onclick="setTool('eraser')">
                    <i class="fas fa-eraser"></i>
                </button>
            </div>

            <div class="flex flex-col items-end">
                <button class="tool-btn bg-red-500 hover:bg-red-600 border-red-400" onclick="clearCanvas()">
                    <i class="fas fa-trash"></i>
                </button>
                
                <!-- Size Slider -->
                <div class="mt-4 bg-black/50 p-2 rounded-lg backdrop-blur-sm">
                    <input type="range" id="size-slider" min="0.01" max="0.1" step="0.01" value="0.02" 
                           class="w-32 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>
        </div>

        <!-- Center Reticle (Used for placing graffiti) -->
        <div id="reticle"></div>

        <!-- Bottom Bar: Colors & Draw Button -->
        <div class="ui-element w-full p-6 flex flex-col items-center pb-8" style="background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);">
            
            <!-- Colors -->
            <div class="flex mb-6 overflow-x-auto pb-2 space-x-2" id="color-palette">
                <!-- Generated by JS -->
            </div>

            <!-- Draw Button -->
            <button id="draw-btn" class="w-full max-w-xs py-4 rounded-xl text-white font-bold text-xl tracking-wide select-none touch-manipulation">
                HOLD TO PAINT
            </button>
        </div>
    </div>

    <script>
        
        function showStartupError(message) {
            document.getElementById('start-screen').style.display = 'none';
            const errorBox = document.getElementById('error-message');
            errorBox.querySelector('p').innerHTML = message;
            errorBox.style.display = 'block';
            console.error(message);
        }

        // --- STARTUP LOGIC ---
        document.addEventListener('DOMContentLoaded', () => {
            const startBtn = document.getElementById('start-ar-btn');
            const startScreen = document.getElementById('start-screen');
            const overlay = document.getElementById('dom-overlay');
            const scene = document.querySelector('a-scene');
            const compatibilityText = document.getElementById('compatibility-check');
            
            // 1. Check WebXR Compatibility
            if (window.navigator.xr) {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    if (supported) {
                        compatibilityText.textContent = 'Device is WebXR compatible. Ready to start AR.';
                        startBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        startBtn.disabled = false;
                    } else {
                        compatibilityText.textContent = 'WebXR AR is not supported on this device/browser.';
                        startBtn.classList.add('opacity-50', 'cursor-not-allowed');
                        startBtn.disabled = true;
                    }
                }).catch(() => {
                    compatibilityText.textContent = 'Could not check WebXR compatibility.';
                    startBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    startBtn.disabled = true;
                });
            } else {
                compatibilityText.textContent = 'WebXR API not found (iOS 13+ required).';
                startBtn.classList.add('opacity-50', 'cursor-not-allowed');
                startBtn.disabled = true;
            }

            startBtn.addEventListener('click', () => {
                // We use the A-Frame component method to enter AR mode, 
                // which automatically handles the camera request (via the browser's UI).
                const webxrComponent = scene.components.webxr;
                
                if (webxrComponent && webxrComponent.enterAR) {
                    startBtn.textContent = 'Starting AR...';
                    
                    // This function is the standard A-Frame method to enter AR mode.
                    webxrComponent.enterAR().then(() => {
                        // AR session successfully started
                        startScreen.style.display = 'none';
                        overlay.style.visibility = 'visible';
                    }).catch(e => {
                        // This catches permission denials (camera, motion) or failed initialization
                        let errorMsg = `AR startup failed: ${e.name || e.message}.`;
                        if (e.name === 'NotAllowedError') {
                            errorMsg += " Check iPhone Settings > Safari > Camera AND Motion/Orientation Access.";
                        }
                        showStartupError(errorMsg);
                        startBtn.textContent = 'Start AR Session';
                        startBtn.disabled = false;
                    });
                } else {
                    showStartupError("WebXR component not ready or AR not supported.");
                    startBtn.textContent = 'Start AR Session';
                    startBtn.disabled = false;
                }
            });

            // Listen for A-Frame's standard events to manage UI visibility
            scene.addEventListener('enter-vr', (e) => {
                if (e.detail.session.domOverlayState) {
                    // Check if it's AR mode (immersive-ar)
                    startScreen.style.display = 'none';
                    overlay.style.visibility = 'visible';
                }
            });
            
            scene.addEventListener('exit-vr', () => {
                startScreen.style.display = 'flex';
                overlay.style.visibility = 'hidden';
                startBtn.textContent = 'Start AR Session';
            });
        });

        // --- CONFIGURATION ---
        const COLORS = [
            '#EF4444', '#F97316', '#FACC15', '#22C55E', 
            '#3B82F6', '#A855F7', '#EC4899', '#FFFFFF', '#000000'
        ];
        
        const STATE = {
            isDrawing: false,
            color: COLORS[0],
            size: 0.02,
            tool: 'brush', // brush, spray, eraser
        };

        // --- DRAWING SYSTEM COMPONENT ---
        AFRAME.registerComponent('drawing-system', {
            init: function () {
                this.currentStroke = null;
                this.strokeData = []; 
                this.lastPoint = null;
                this.raycaster = new THREE.Raycaster();
                
                // Input Handling
                const btn = document.getElementById('draw-btn');
                
                const start = (e) => { 
                    if(e.touches && e.touches.length > 1) return;
                    e.preventDefault(); 
                    this.startAction(); 
                };
                const end = (e) => { 
                    e.preventDefault(); 
                    this.endAction(); 
                };

                btn.addEventListener('mousedown', start);
                btn.addEventListener('touchstart', start);
                
                window.addEventListener('mouseup', end);
                window.addEventListener('touchend', end);
                window.addEventListener('touchcancel', end); 
            },

            startAction: function () {
                // Only allow drawing if in AR mode
                if (!this.el.sceneEl.is('ar-mode')) return;
                
                STATE.isDrawing = true;
                this.strokeData = [];
                this.lastPoint = null;
                
                // Visual Feedback
                document.getElementById('draw-btn').style.transform = "scale(0.95)";
                document.getElementById('draw-btn').style.filter = "brightness(0.9)";
            },

            endAction: function () {
                if (!STATE.isDrawing) return;
                STATE.isDrawing = false;
                this.currentStroke = null;
                
                // Reset Button
                document.getElementById('draw-btn').style.transform = "scale(1)";
                document.getElementById('draw-btn').style.filter = "brightness(1)";
            },

            tick: function (time, deltaTime) {
                if (!STATE.isDrawing || !this.el.sceneEl.is('ar-mode')) return;

                const camera = this.el.sceneEl.camera;
                if (!camera) return;

                // Use a simple forward projection for world placement
                const point = this.getDrawingPosition(camera);

                // Handle Eraser
                if (STATE.tool === 'eraser') {
                    this.eraseAt(point);
                    return;
                }

                // Handle Drawing (Brush or Spray)
                const distanceThreshold = STATE.size * 0.3;
                if (this.lastPoint && point.distanceTo(this.lastPoint) < distanceThreshold) {
                    return; // Too close to last point
                }

                if (STATE.tool === 'brush') {
                    this.drawBrushSegment(this.lastPoint || point, point, STATE.color, STATE.size);
                } else if (STATE.tool === 'spray') {
                    this.drawSprayParticles(point, STATE.color, STATE.size);
                }

                this.strokeData.push(point.clone());
                this.lastPoint = point.clone();
            },

            getDrawingPosition: function(camera) {
                // Projects a point 1.5m in front of the camera using the camera's world direction
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                
                const worldPos = new THREE.Vector3();
                worldPos.copy(camera.position).add(direction.multiplyScalar(1.5));
                return worldPos;
            },

            drawBrushSegment: function(from, to, color, size) {
                const distance = from.distanceTo(to);
                if (distance === 0) return;

                const geometry = new THREE.CylinderGeometry(size/2, size/2, distance, 6, 1, false);
                const material = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    roughness: 1, 
                    flatShading: true,
                    emissive: color, 
                    emissiveIntensity: 0.1
                });
                
                const cylinder = new THREE.Mesh(geometry, material);
                
                const midPoint = new THREE.Vector3().addVectors(from, to).multiplyScalar(0.5);
                cylinder.position.copy(midPoint);
                cylinder.lookAt(to);
                cylinder.rotateX(Math.PI / 2); 
                
                const jointGeo = new THREE.SphereGeometry(size/2, 6, 6);
                const joint = new THREE.Mesh(jointGeo, material);
                joint.position.copy(from);

                const group = new THREE.Group();
                group.add(cylinder);
                group.add(joint);
                
                group.userData.isStroke = true;
                
                this.el.object3D.add(group);
            },

            drawSprayParticles: function(center, color, size) {
                const particleCount = 4;
                const sprayRadius = size * 3;
                
                const geometry = new THREE.PlaneGeometry(size/2, size/2);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color, 
                    transparent: true, 
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });

                for(let i=0; i<particleCount; i++) {
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * sprayRadius,
                        (Math.random() - 0.5) * sprayRadius,
                        (Math.random() - 0.5) * sprayRadius
                    );
                    
                    mesh.position.copy(center).add(offset);
                    mesh.lookAt(this.el.sceneEl.camera.position); 
                    mesh.userData.isStroke = true;
                    
                    this.el.object3D.add(mesh);
                }
            },

            eraseAt: function(point) {
                const eraserRadius = STATE.size * 3;
                const container = this.el.object3D;
                const children = container.children;
                
                for (let i = children.length - 1; i >= 0; i--) {
                    const child = children[i];
                    if (child.userData.isStroke) {
                        const childWorldPos = new THREE.Vector3();
                        child.getWorldPosition(childWorldPos);
                        
                        if (childWorldPos.distanceTo(point) < eraserRadius) {
                            container.remove(child);
                        }
                    }
                }
            },
        });

        // --- UI LOGIC ---

        function initUI() {
            // Generate Color Palette
            const palette = document.getElementById('color-palette');
            COLORS.forEach((color, index) => {
                const btn = document.createElement('button');
                btn.className = `color-btn ${index === 0 ? 'active' : ''}`;
                btn.style.backgroundColor = color;
                btn.onclick = () => {
                    STATE.color = color;
                    document.getElementById('reticle').style.borderColor = color;
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    if (STATE.tool !== 'eraser') {
                        document.getElementById('reticle').style.borderColor = color;
                    }
                };
                palette.appendChild(btn);
            });

            // Size Slider
            document.getElementById('size-slider').addEventListener('input', (e) => {
                STATE.size = parseFloat(e.target.value);
                const px = 10 + (STATE.size * 500); 
                const reticle = document.getElementById('reticle');
                reticle.style.width = `${px}px`;
                reticle.style.height = `${px}px`;
            });
            document.getElementById('size-slider').dispatchEvent(new Event('input'));
        }

        window.setTool = (toolName) => {
            STATE.tool = toolName;
            
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`tool-${toolName}`).classList.add('active');

            const reticle = document.getElementById('reticle');
            if (toolName === 'eraser') {
                reticle.style.borderStyle = 'dashed';
                reticle.style.borderColor = 'white';
                reticle.style.backgroundColor = 'transparent';
            } else if (toolName === 'spray') {
                reticle.style.borderStyle = 'dotted';
                reticle.style.borderColor = STATE.color;
                reticle.style.backgroundColor = 'transparent';
            } else { // brush
                reticle.style.borderStyle = 'solid';
                reticle.style.borderColor = STATE.color;
                reticle.style.backgroundColor = 'transparent';
            }
        };

        window.clearCanvas = () => {
            const doClear = window.prompt("Type 'CLEAR' (in all caps) to confirm clearing your local graffiti:");
            
            if (doClear === 'CLEAR') {
                const drawingEntity = document.getElementById('drawing-container');
                
                if (drawingEntity) {
                    const object3D = drawingEntity.object3D;
                    for (let i = object3D.children.length - 1; i >= 0; i--) {
                        if (object3D.children[i].userData.isStroke) {
                            object3D.remove(object3D.children[i]);
                        }
                    }
                }
            } else if (doClear !== null) {
                console.log("Clear canceled.");
            }
        };

        initUI();
        window.setTool('brush');

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AR Graffiti Studio</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- A-Frame (3D Framework) -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>

    <!-- FontAwesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Variables
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-ar-painter';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const authToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        if (Object.keys(firebaseConfig).length > 0) {
            const app = initializeApp(firebaseConfig);
            window.db = getFirestore(app);
            window.auth = getAuth(app);
            
            // Expose Firestore functions to global scope for A-Frame component
            window.collection = collection;
            window.addDoc = addDoc;
            window.onSnapshot = onSnapshot;
            window.query = query;
            window.serverTimestamp = serverTimestamp;
        }

        window.initFirebase = async () => {
            if (!window.auth) return;
            try {
                if (authToken) await signInWithCustomToken(window.auth, authToken);
                else await signInAnonymously(window.auth);
                window.userId = window.auth.currentUser?.uid || crypto.randomUUID();
                
                // Set path and enable sync
                window.DRAWING_COLLECTION_PATH = `/artifacts/${appId}/public/data/drawings`;
                
                // Signal component to start listening
                const scene = document.querySelector('a-scene');
                if(scene) scene.emit('firebase-ready');
                
            } catch (error) { console.error("Auth error:", error); }
        };
        window.initFirebase();
    </script>

    <style>
        /* DOM Overlay allows UI to sit on top of the WebXR view */
        #dom-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let touches pass through to canvas by default */
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            visibility: hidden; /* Hidden until AR starts */
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: #111;
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            padding: 20px;
            text-align: center;
        }

        /* Interactive elements inside the overlay must re-enable pointer-events */
        .ui-element {
            pointer-events: auto;
        }

        /* Tool Buttons */
        .tool-btn {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: rgba(20, 20, 20, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            margin-bottom: 8px;
        }
        .tool-btn.active {
            background: #3B82F6;
            border-color: white;
            transform: scale(1.1);
        }

        /* Color Buttons */
        .color-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            margin: 0 6px;
            transform: scale(1);
            transition: transform 0.2s;
        }
        .color-btn.active {
            transform: scale(1.3);
            border-color: #3B82F6;
        }

        /* Main Draw Button */
        #draw-btn {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
        }
        #draw-btn:active {
            transform: scale(0.95);
        }
        
        #reticle {
            position: absolute;
            top: 50%; left: 50%;
            width: 12px; height: 12px;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 8px rgba(0,0,0,0.5);
            transition: width 0.2s, height 0.2s, background-color 0.2s;
        }
    </style>
</head>
<body class="bg-gray-900 overflow-hidden">

    <!-- Start Screen Overlay -->
    <div id="start-screen">
        <h1 class="text-4xl font-bold mb-4 bg-gradient-to-r from-blue-400 to-green-400 bg-clip-text text-transparent">AR Graffiti</h1>
        <p class="mb-8 text-gray-300 max-w-md">Paint on the real world with friends. <br> Requires camera permissions.</p>
        <button id="start-ar-btn" class="px-8 py-4 bg-blue-600 rounded-full font-bold text-xl shadow-lg hover:bg-blue-500 transition transform hover:scale-105">
            Start AR Session
        </button>
        <p class="mt-8 text-xs text-gray-500">Works best on Chrome Android or WebXR Viewer (iOS)</p>
    </div>

    <!-- WebXR Scene -->
    <!-- vr-mode-ui="enabled: false" hides the default button so we can use our custom start screen -->
    <a-scene 
        vr-mode-ui="enabled: false"
        webxr="optionalFeatures: hit-test, dom-overlay; overlayElement: #dom-overlay;"
        background="color: #333; transparent: true"
        renderer="antialias: true; colorManagement: true; physicallyCorrectLights: true;">

        <a-camera position="0 1.6 0" look-controls="enabled: true"></a-camera>
        
        <!-- The container for all drawings -->
        <a-entity id="drawing-container" drawing-system></a-entity>

        <!-- Lighting for the spray particles -->
        <a-light type="ambient" color="#BBB"></a-light>
        <a-light type="directional" position="-1 2 1" intensity="0.5"></a-light>
    </a-scene>

    <!-- UI Overlay (Visible in AR) -->
    <div id="dom-overlay">
        
        <!-- Top Bar: Tools -->
        <div class="ui-element p-4 flex justify-between items-start w-full">
            <div class="flex flex-col">
                <button class="tool-btn active" id="tool-brush" onclick="setTool('brush')">
                    <i class="fas fa-paint-brush"></i>
                </button>
                <button class="tool-btn" id="tool-spray" onclick="setTool('spray')">
                    <i class="fas fa-spray-can"></i>
                </button>
                <button class="tool-btn" id="tool-eraser" onclick="setTool('eraser')">
                    <i class="fas fa-eraser"></i>
                </button>
            </div>

            <div class="flex flex-col items-end">
                <button class="tool-btn bg-red-500 hover:bg-red-600 border-red-400" onclick="clearCanvas()">
                    <i class="fas fa-trash"></i>
                </button>
                
                <!-- Size Slider -->
                <div class="mt-4 bg-black/50 p-2 rounded-lg backdrop-blur-sm">
                    <input type="range" id="size-slider" min="0.01" max="0.1" step="0.01" value="0.02" 
                           class="w-32 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>
        </div>

        <!-- Center Reticle -->
        <div id="reticle"></div>

        <!-- Bottom Bar: Colors & Draw Button -->
        <div class="ui-element w-full p-6 flex flex-col items-center pb-8" style="background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);">
            
            <!-- Colors -->
            <div class="flex mb-6 overflow-x-auto pb-2 space-x-2" id="color-palette">
                <!-- Generated by JS -->
            </div>

            <!-- Draw Button -->
            <button id="draw-btn" class="w-full max-w-xs py-4 rounded-xl text-white font-bold text-xl tracking-wide select-none touch-manipulation">
                HOLD TO PAINT
            </button>
        </div>
    </div>

    <script>
        // --- STARTUP LOGIC ---
        document.addEventListener('DOMContentLoaded', () => {
            const startBtn = document.getElementById('start-ar-btn');
            const startScreen = document.getElementById('start-screen');
            const overlay = document.getElementById('dom-overlay');
            const scene = document.querySelector('a-scene');

            startBtn.addEventListener('click', () => {
                // Request to enter AR mode
                // This call requires a user gesture (click), which we are inside of.
                // It triggers the permission prompt.
                scene.enterVR(); 
            });

            // Listen for entering AR to switch UI
            scene.addEventListener('enter-vr', () => {
                startScreen.style.display = 'none';
                overlay.style.visibility = 'visible';
            });
            
            // Listen for exit to show start screen again (optional)
            scene.addEventListener('exit-vr', () => {
                startScreen.style.display = 'flex';
                overlay.style.visibility = 'hidden';
            });
        });

        // --- CONFIGURATION ---
        const COLORS = [
            '#EF4444', '#F97316', '#FACC15', '#22C55E', 
            '#3B82F6', '#A855F7', '#EC4899', '#FFFFFF', '#000000'
        ];
        
        const STATE = {
            isDrawing: false,
            color: COLORS[0],
            size: 0.02,
            tool: 'brush', // brush, spray, eraser
            userId: null
        };

        // --- DRAWING SYSTEM COMPONENT ---
        AFRAME.registerComponent('drawing-system', {
            init: function () {
                this.currentStroke = null;
                this.strokeData = [];
                this.lastPoint = null;
                this.raycaster = new THREE.Raycaster();
                
                // Firestore Listener
                this.el.sceneEl.addEventListener('firebase-ready', () => {
                   this.setupFirestore();
                });

                // Input Handling
                const btn = document.getElementById('draw-btn');
                
                const start = (e) => { 
                    e.preventDefault(); 
                    if(e.touches && e.touches.length > 1) return;
                    this.startAction(); 
                };
                const end = (e) => { 
                    e.preventDefault(); 
                    this.endAction(); 
                };

                btn.addEventListener('mousedown', start);
                btn.addEventListener('touchstart', start);
                
                window.addEventListener('mouseup', end);
                window.addEventListener('touchend', end);
            },

            setupFirestore: function() {
                if(!window.db || !window.DRAWING_COLLECTION_PATH) return;
                
                // Use window.* versions since the module scope isn't shared
                const q = window.query(window.collection(window.db, window.DRAWING_COLLECTION_PATH));
                window.onSnapshot(q, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === "added") {
                            const data = change.doc.data();
                            // Don't redraw our own strokes immediately to avoid duplication 
                            // (In a prod app you'd handle local/remote IDs better)
                            if (data.userId !== window.userId) {
                                this.renderRemoteStroke(data);
                            }
                        }
                    });
                });
            },

            startAction: function () {
                STATE.isDrawing = true;
                this.strokeData = [];
                this.lastPoint = null;
                
                // Visual Feedback
                document.getElementById('draw-btn').style.transform = "scale(0.95)";
                document.getElementById('draw-btn').style.filter = "brightness(0.9)";
            },

            endAction: function () {
                if (!STATE.isDrawing) return;
                STATE.isDrawing = false;
                this.currentStroke = null;
                
                // Reset Button
                document.getElementById('draw-btn').style.transform = "scale(1)";
                document.getElementById('draw-btn').style.filter = "brightness(1)";

                // Save to Firestore
                if (window.db && window.DRAWING_COLLECTION_PATH && this.strokeData.length > 0 && STATE.tool !== 'eraser') {
                    // Compress data slightly (array of arrays)
                    const segments = this.strokeData.map(v => [
                        Number(v.x.toFixed(3)), 
                        Number(v.y.toFixed(3)), 
                        Number(v.z.toFixed(3))
                    ]);

                    // Use global window.addDoc and window.collection
                    window.addDoc(window.collection(window.db, window.DRAWING_COLLECTION_PATH), {
                        userId: window.userId,
                        color: STATE.color,
                        size: STATE.size,
                        tool: STATE.tool,
                        points: segments,
                        timestamp: window.serverTimestamp()
                    });
                }
            },

            tick: function (time, deltaTime) {
                if (!STATE.isDrawing) return;

                const camera = this.el.sceneEl.camera;
                if (!camera) return;

                // 1. Get Hit Point (2 meters in front of camera)
                const point = this.getHitPoint(camera);

                // 2. Handle Eraser
                if (STATE.tool === 'eraser') {
                    this.eraseAt(point);
                    return;
                }

                // 3. Handle Drawing (Brush or Spray)
                if (this.lastPoint && point.distanceTo(this.lastPoint) < (STATE.size * 0.5)) {
                    return; // Too close to last point
                }

                if (STATE.tool === 'brush') {
                    this.drawBrushSegment(this.lastPoint || point, point, STATE.color, STATE.size);
                } else if (STATE.tool === 'spray') {
                    this.drawSprayParticles(point, STATE.color, STATE.size);
                }

                this.strokeData.push(point.clone());
                this.lastPoint = point.clone();
            },

            getHitPoint: function(camera) {
                // Creates a virtual drawing plane 1.5m away
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.multiplyScalar(1.5); // Distance from phone
                return camera.position.clone().add(direction);
            },

            drawBrushSegment: function(from, to, color, size) {
                // Using cylinders for smoother thick lines than LineSegments
                const distance = from.distanceTo(to);
                if (distance === 0) return;

                const geometry = new THREE.CylinderGeometry(size/2, size/2, distance, 6);
                const material = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    roughness: 1, 
                    flatShading: true 
                });
                
                const cylinder = new THREE.Mesh(geometry, material);
                
                // Align cylinder to the two points
                const midPoint = new THREE.Vector3().addVectors(from, to).multiplyScalar(0.5);
                cylinder.position.copy(midPoint);
                cylinder.lookAt(to);
                cylinder.rotateX(Math.PI / 2); // Cylinder creates pointing up, rotate to face target
                
                // Add sphere for joint smoothing
                const jointGeo = new THREE.SphereGeometry(size/2, 6, 6);
                const joint = new THREE.Mesh(jointGeo, material);
                joint.position.copy(from);

                const group = new THREE.Group();
                group.add(cylinder);
                group.add(joint);
                
                // Tag for eraser
                group.userData.isStroke = true;
                
                this.el.object3D.add(group);
            },

            drawSprayParticles: function(center, color, size) {
                const particleCount = 4;
                const sprayRadius = size * 3;
                
                const geometry = new THREE.PlaneGeometry(size/2, size/2);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color, 
                    transparent: true, 
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });

                for(let i=0; i<particleCount; i++) {
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // Random offset within sphere
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * sprayRadius,
                        (Math.random() - 0.5) * sprayRadius,
                        (Math.random() - 0.5) * sprayRadius
                    );
                    
                    mesh.position.copy(center).add(offset);
                    mesh.lookAt(this.el.sceneEl.camera.position); // Billboard effect
                    mesh.userData.isStroke = true;
                    
                    this.el.object3D.add(mesh);
                }
            },

            eraseAt: function(point) {
                // Simple distance-based erasure
                const eraserRadius = STATE.size * 3;
                const children = this.el.object3D.children;
                
                // Iterate backwards to safely remove
                for (let i = children.length - 1; i >= 0; i--) {
                    const child = children[i];
                    if (child.userData.isStroke) {
                        // Check distance to the group or mesh
                        if (child.position.distanceTo(point) < eraserRadius) {
                            this.el.object3D.remove(child);
                            // Also try to remove detailed children if it's a group
                        } else if (child.children.length > 0) {
                             // Check inner children (like the cylinder in the group)
                             if (child.children[0].position.distanceTo(point) < eraserRadius || 
                                 child.position.distanceTo(point) < eraserRadius) {
                                 this.el.object3D.remove(child);
                             }
                        }
                    }
                }
            },

            renderRemoteStroke: function(data) {
                if(!data.points || data.points.length < 2) return;
                
                // Reconstruct Vector3s
                const points = data.points.map(p => new THREE.Vector3(p[0], p[1], p[2]));
                
                if (data.tool === 'brush') {
                    for(let i=0; i<points.length-1; i++) {
                        this.drawBrushSegment(points[i], points[i+1], data.color, data.size);
                    }
                } else if (data.tool === 'spray') {
                    points.forEach(p => {
                        this.drawSprayParticles(p, data.color, data.size);
                    });
                }
            }
        });

        // --- UI LOGIC ---

        function initUI() {
            // Generate Color Palette
            const palette = document.getElementById('color-palette');
            COLORS.forEach((color, index) => {
                const btn = document.createElement('button');
                btn.className = `color-btn ${index === 0 ? 'active' : ''}`;
                btn.style.backgroundColor = color;
                btn.onclick = () => {
                    STATE.color = color;
                    document.getElementById('reticle').style.borderColor = color;
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                };
                palette.appendChild(btn);
            });

            // Size Slider
            document.getElementById('size-slider').addEventListener('input', (e) => {
                STATE.size = parseFloat(e.target.value);
                const px = 10 + (STATE.size * 500);
                const reticle = document.getElementById('reticle');
                reticle.style.width = `${px}px`;
                reticle.style.height = `${px}px`;
            });
        }

        window.setTool = (toolName) => {
            STATE.tool = toolName;
            
            // Update UI
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`tool-${toolName}`).classList.add('active');

            // Update Reticle Style
            const reticle = document.getElementById('reticle');
            if (toolName === 'eraser') {
                reticle.style.borderStyle = 'dashed';
                reticle.style.borderColor = 'white';
            } else if (toolName === 'spray') {
                reticle.style.borderStyle = 'dotted';
                reticle.style.borderColor = STATE.color;
            } else {
                reticle.style.borderStyle = 'solid';
                reticle.style.borderColor = STATE.color;
            }
        };

        window.clearCanvas = () => {
            if(confirm("Clear your drawing?")) {
                const container = document.getElementById('drawing-container');
                while(container.object3D.children.length > 0){ 
                    container.object3D.remove(container.object3D.children[0]); 
                }
            }
        };

        // Initialize
        initUI();

    </script>
</body>
</html>
